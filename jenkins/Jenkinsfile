import groovy.json.JsonSlurper



def cloudformationStackArn = ""
def cfStackStatusFilters = [
    "CREATE_IN_PROGRESS",
    "CREATE_FAILED",
    "CREATE_COMPLETE",
    "ROLLBACK_IN_PROGRESS",
    "ROLLBACK_FAILED",
    "ROLLBACK_COMPLETE",
    "DELETE_IN_PROGRESS"
]

def createCfStack = null

pipeline { 
    agent any

    parameters {
        string(name: 'CFStackName', defaultValue: 'morova-eks-cluster', description: 'The name of the AWS CF stack to use / create')
        string(name: 'EKSClusterName', defaultValue: 'morova-eks-cluster', description: 'The name of the AWS EKS cluster')
        string(name: 'AWSRegion', defaultValue: 'us-east-2', description: 'The AWS region to use')
        string(name: 'S3Bucket', defaultValue: 'morova-bucket', description: 'The name of the S3 bucket to store the CF template')
        booleanParam(name: 'DeployTools', defaultValue: true, description: 'Set to TRUE to deploy Grafana, Chaos Mesh, Prometheus, etc.')
        booleanParam(name: 'DeploySUT', defaultValue: true, description: 'Set to TRUE to deploy the SUT')
        booleanParam(name: 'RunMeasurement', defaultValue: true, description: 'Set to TRUE to run the measurements against the SUT')
        // booleanParam(name: 'DeleteNamespaces', defaultValue: true, description: 'Set to TRUE to delete namespaces')
        booleanParam(name: 'DeleteCFStack', defaultValue: true, description: 'Set to TRUE to delete the CloudFormation stack at the end of the pipeline')
        booleanParam(name: 'CleanWorkSpace', defaultValue: true, description: 'Set to TRUE to delete workspace at the end of the pipeline')
        
        choice(name: 'MEASFaultProfile', choices: ['none','podFailureChaos', 'io', 'network-delay', 'network-partition', 'pod-failure', 'pod-kill', 'stress-cpu', 'stress-mem', 'custom'], description: 'Name of the fault profile')
        string(name: 'MEASMeasurementCount', defaultValue: '10', description: 'Number of measurements to make during the measurement sequence')
        string(name: 'MEASLoadDuration', defaultValue: '600', description: 'Duration of the load generation in a single measurement in SECONDS')
        choice(name: 'MEASClusterType', choices: ['eks', 'minikube'], description: 'Type of the K8s cluster the stack runs on')
        string(name: 'MEASLocustUserCount', defaultValue: '1', description: 'Total number of Locust users to start')
        string(name: 'MEASLocustSpawnRate', defaultValue: '1', description: 'Number of Locust users to spawn per second')
        string(name: 'MEASComment', defaultValue: '', description: 'Give a comment about the measurement sequence')
    }

    options {
        skipStagesAfterUnstable()
        skipDefaultCheckout()
        timeout(time: 6, unit: 'HOURS')
        timestamps()
    }



    // environment {
    //     // AWS_REGION="us-east-2"
    // }

    stages {
        stage('Prepare build') {
            steps {
                checkout scm
                sh "aws --version"
                // echo "DeleteNamespaces= $DeleteNamespaces"

                echo "Setup aws config"
                script {

                    println DeployTools

                    withCredentials(
                    [
                        usernamePassword(
                            credentialsId: 'aws-key',
                            usernameVariable: 'AWS_ACCESS_KEY_ID',
                            passwordVariable: 'AWS_SECRET_ACCESS_KEY'
                        ),
                        string(
                            credentialsId: 'aws-session-token',
                            variable: 'AWS_SESSION_TOKEN'
                        )
                    ]
                    ) {
                        sh """
                            |aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
                            |aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
                            |#aws configure set aws_session_token $AWS_SESSION_TOKEN
                            |aws configure set default.region $AWSRegion
                            |aws configure set default.output json
                        """.stripMargin('|')
                    }
                }            
            }
        }

        stage('INFR - check') {

            steps {
                echo "Check if CloudFormation stack exists"
                // TODO use "aws cloudformation describe-stacks --stack-name morova-eks-clusterd --region us-east-2" to simplify
                
                script {
                    echo "Check if '$CFStackName' CloudFormation stack exists"
                    def stacksResult = sh(
                        script: "aws cloudformation list-stacks --stack-status-filter ${cfStackStatusFilters.join(' ')} | jq -r '.StackSummaries | map(select(.StackName == \"$CFStackName\"))'",
                        returnStdout: true
                    ).trim()
                    def jsonSlurper = new JsonSlurper()
                    def stacksResultParsed = jsonSlurper.parseText(stacksResult)
                    println "Parsed result of stacks: ${stacksResultParsed}"

                    if (stacksResultParsed.size() == 0) {
                        println "CloudFormation stack(s) '${CFStackName}' does/do not exists (or has/have status DELETE_COMPLETE)"
                        createCfStack = true
                    } else if (stacksResultParsed.size() == 1) {
                        println "CloudFormation stack '${CFStackName}' already exists"
                        createCfStack = false

                        def stack = stacksResultParsed[0]
                        switch(stack.StackStatus) {
                            case "CREATE_COMPLETE":
                                println "CloudFormation stack is ready!"
                            default:
                                error("CF stack named '${CFStackName}' with ARN '${stack.StackId}' has status '${stack.StackStatus}' - probably another job is working with it or check AWS Console")

                        }
                    } else {
                        error("Multiple CF stacks exist named '${CFStackName}' with status from  [${cfStackStatusFilters.join(', ')}]")
                    }
                }
                
            }
        }

        stage('INFR - create') {
            when { expression { createCfStack } }

            steps {
                script {
                    // Uploading does not work, --body parameter parse error
                    // echo "Upload CF template to S3"
                    // def uploadResult = sh(
                    //     script: "aws s3api --debug put-object --bucket $S3Bucket --key eks/infrastructure.yaml --body ./utils/infrastructure.yaml",
                    //     returnStdout: true
                    // ).trim()
                    // println "uploadResult = ${uploadResult}"

                    echo "Create CloudFormation stack"
                    def stackId = sh(
                        script: "aws cloudformation create-stack --stack-name $CFStackName --template-url https://morova-bucket.s3.us-east-2.amazonaws.com/eks/infrastructure.yaml --parameters ParameterKey=ClusterName,ParameterValue=$EKSClusterName --capabilities CAPABILITY_NAMED_IAM | jq -r '.StackId'",
                        returnStdout: true
                    ).trim()
                    // println "creationResult = ${creationResult}"
                    // def jsonSlurper = new JsonSlurper()
                    // def stackId = jsonSlurper.parseText(creationResult).StackId

                    println "stackId = ${stackId}"
                    cloudformationStackArn = stackId

                    waitUntil(initialRecurrencePeriod: 15000) {
                        echo "Waiting for CloudFormation stack to get ready..."
                        def stackStatus = sh(
                            script: "aws cloudformation list-stacks | jq -r '.StackSummaries[] | select(.StackId == \"${stackId}\").StackStatus'",
                            returnStdout: true
                        ).trim()

                        switch(stackStatus) {
                            case "CREATE_COMPLETE":
                                println "CF Stack ready"
                                return true
                            case "ROLLBACK_COMPLETE":
                                error("Failed to create CloudFormation stack - check AWS console")
                            default:
                                println "'$CFStackName' CF stack not ready yet"
                                return false
                        }
                    }
                }
                
            }
        }

        stage ('INFR - config kubectl') {
            steps {
                echo "Configuring kubectl"
                script {
                    sh """
                    |kubectl version --client
                    |aws eks update-kubeconfig --name $EKSClusterName
                    |kubectl get ns
                    """.stripMargin('|')
                }
            }
        }

        stage ('INFR - update helm repos') {
            when { expression { DeployTools == 'true' } }

            steps {
                echo "Add helm repos"
                script {
                    sh """
                    |helm version
                    |helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
                    |helm repo add grafana https://grafana.github.io/helm-charts
                    |helm repo add chaos-mesh https://charts.chaos-mesh.org
                    |helm repo update
                    """.stripMargin('|')
                }
            }
        }

        stage ('INFR - deploy tools') {
            when { expression { DeployTools == 'true' } }
            steps {
                echo "Deploy Prometheus, Prometheus Blackbox Exporter, Prometheus Adapter, Grafana, Chaos Mesh"
                script {
                    sh """
                    |kubectl apply -f k8s-deployment/000-namespaces.yaml
                    |helm upgrade --install prometheus prometheus-community/prometheus -n monitoring -f helm/prometheus/values.yaml
                    |helm upgrade --install prometheus-blackbox-exporter prometheus-community/prometheus-blackbox-exporter -n monitoring -f helm/blackbox-exporter/values.yaml
                    |helm upgrade --install prometheus-adapter prometheus-community/prometheus-adapter -n monitoring -f helm/prometheus-adapter/values.yaml
                    |helm upgrade --install grafana grafana/grafana -n monitoring -f helm/grafana/values.yaml
                    |echo "Grafana secret is:"
                    |kubectl get secret --namespace monitoring grafana -o jsonpath="{.data.admin-password}" | base64 --decode ; echo
                    |helm upgrade --install chaos-mesh chaos-mesh/chaos-mesh --namespace=chaos-testing -f helm/chaos-mesh/values.yaml --version v0.5.3
                    """.stripMargin('|')
                }
            }
        }


        stage('APP - deploy') {
            when { expression { DeploySUT == 'true' } }
            steps {
                echo "Deploy application"
                script {
                    sh """
                    |kubectl apply -f k8s-deployment/004-deployments.yaml
                    |kubectl apply -f k8s-deployment/001-configmaps.yaml
                    |kubectl apply -f k8s-deployment/005-services.yaml
                    |kubectl apply -f k8s-deployment/metrics-server.yaml
                    |kubectl apply -f k8s-deployment/400-hpa.yaml
                    """.stripMargin('|')
                }
            }
        }

        stage('MEAS - config') {
            when { expression { RunMeasurement == 'true' } }
            steps {
                echo "Install dependencies for kubedepend"
                dir('kubedepend') {
                    sh """
                    |pipenv install
                    """.stripMargin('|')
                }
            }
        }

        stage('MEAS - Running tests') {
            when { expression { RunMeasurement == 'true' } }
            steps {
                dir('kubedepend/kubedepend') {
                    sh """
                    |echo "Opening ports..."
                    |kubectl -n monitoring port-forward service/prometheus-server 9090:80 &
                    |PROM_PORT_FW_PID=\$!
                    |kubectl -n measurement-proxy port-forward service/measurement-proxy 8000:80 &
                    |MEAS_PROXY_PORT_FW_PID=\$!
                    |echo "Running tests"
                    |pipenv run python kubedepend.py --fault-profile=$MEASFaultProfile --measurement-count=$MEASMeasurementCount --load-duration=$MEASLoadDuration --cluster-type=$MEASClusterType --locust_user_count=$MEASLocustUserCount --locust_spawn_rate=$MEASLocustSpawnRate --comment=\"$MEASComment\"
                    """.stripMargin('|')
                }
            }
        }

        stage('MEAS - Save test results') {
            when { expression { RunMeasurement == 'true' } }
            steps {
                dir('kubedepend/kubedepend/results') {
                    archiveArtifacts artifacts: '*'
                }
            }
        }

        // stage('CLEAN - namespaces') {
        //     when { expression { DeleteNamespaces == true } }

        //     steps {
        //         echo "Delete namespaces"
        //         sh """
        //         |kubectl delete -f k8s-deployment/000-namespaces.yaml
        //         """.stripMargin('|')
        //     }
        // }

        stage('CLEAN - infrastructure') {
            when { expression { DeleteCFStack == 'true' } }
            
            steps {
                echo "Clean up CloudFormation stack"
                sh """
                |aws cloudformation delete-stack --stack-name $CFStackName
                """.stripMargin('|')
            }
        }

        stage('CLEAN - workspace') {
            when { expression { CleanWorkSpace == 'true' } }

            steps {
                cleanWs()
            }
        }
    }
}