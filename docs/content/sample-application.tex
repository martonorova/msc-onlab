%----------------------------------------------------------------------------
\chapter{Sample application}
%----------------------------------------------------------------------------

This chapter presents the design and implementation of the sample application which will act as a case-study to showcase the features of the test framework and to serve as a basis for future enhancements. 


%----------------------------------------------------------------------------
\section{Design} \label{design}
%----------------------------------------------------------------------------

%----------------------------------------------------------------------------
\subsection{Requirements} \label{sample-app-requirements}
%----------------------------------------------------------------------------

%\begin{itemize}
%	\item objectives
%	\begin{itemize}
%		\item microservices architecture
%		\item containerization - facilitates easy deployment and scalability
%		\item have a system with different components based on state-fullness (stateful, stateless, )
%		\item have component(s) that can be scaled based on some application specific workload requirements (e.g. increased load on the system, fault tolerant redundancy) - stateless components can be scaled more easily
%		\item observable and collectible application specific metrics
%	\end{itemize}
%\end{itemize}

The design of the sample application was driven by several requirements to create a system that can be easily used for our purposes.

\paragraph{Kubernetes ready}The purpose of the thesis is to inspect dependability metrics in Kubernetes environments, this naturally means that the application should be able to run on a Kubernetes cluster.

\paragraph{Microservices architecture}As the application needs to be deployed and function in a Kubernetes-based environment, it was evident that a microservice architecture was the right choice for starting the design of the system. This notion implicitly means that there will be multiple, independent components that have to communicate with each other in order to create a whole system.

\paragraph{Scalability}In a real world application it is quite important to create systems that by design can handle different amount of workloads without any major impact on user experience. At the same, an economic use of resources is also a significant requirement, so the system does not reserve too much resources and keeps them idle(\eg CPU, memory, storage, network bandwidth). That means the system should be able to dynamically change and fine tune its capacity and performance to satisfy both constraints. In addition, the application specific triggers for scaling should also be clearly defined.

\paragraph{Containerization}The ease of deployment and scalability is one of the cardinal goals of designing and maintaining a microservice application. Containerization provides the fundamentals for achieving this as all the dependencies and configuration needed for a component can be placed in a container. This leads to the conclusion that each component should be packaged and deployed into separate and independent containers.  In terms of scalability this form of packaging and deployment enables horizontal scaling, that means \eg during a bigger system usage, more instances of a given components should be started instead of increasing the resources of a single component instance.

\paragraph{Stateful and stateless components}The aim of the sample application is to attempt to provide a fair generalization of different kind of system components. A popular classification is deciding whether a component is stateful or stateless. This characteristic greatly affects how a given is able to scale as stateless components are usually easier to manage in terms of scalability. To have the possibility of showcasing the scenario of scaling both types of components, there should be both stateful and stateless components in the case study system.

\paragraph{Observable application metrics}In order to be able to reason about the dependability and performance of the system, different kind of numerical metrics should be available to evaluate. This poses the requirement to create a system that can be easily monitored. The 
components should provide an interface that other tools can use to collect metrics describing both application specific behavior and the state of underlying layers (\eg CPU usage, memory usage, network communication).


%----------------------------------------------------------------------------
\subsection{Architecture}
%----------------------------------------------------------------------------

Although the aim of the sample application is to attempt to provide a generalized system to fit many use-cases without limiting possibilities, when it comes to architectural design, it is indispensable to create the structure of the system with a specific use-case in mind. But with a fairly common use case, the fundamental goal can be roughly preserved.

For this project, a master-worker architecture was chosen, where the master component receives input from clients and then assigns computational tasks to the workers based on the parameters. The computation should be resource heavy (\eg require much CPU time) and should last for an easily measurable time (minimum 30-40 seconds). This architecture allows to easily define scalable, and both stateful and stateless components. The abstract workflow of the use case is the following:

TODO: activity diagram?

\begin{enumerate}
	\item \emph{Input submission} A client submits input parameters to the master component.
	\item \emph{Task distribution} The master component creates a task definition based on the input parameters and then forwards it to one of the worker components.
	\item \emph{Task execution} The worker components executes the received task and sends back the result to the master.
	\item \emph{Persisting results} The master persists the result of the completed task so it can be queried by clients.
\end{enumerate}

The designed architecture of the sample application can be seen in Figure \ref{fig:sample_app_arch}

\begin{figure}[h]
	\centering
	\includegraphics[width=130mm, keepaspectratio]{figures/sample_app_arch.png}
	\caption{Sample application architecture}
	\label{fig:sample_app_arch}
\end{figure}
%
%%----------------------------------------------------------------------------
%\subsection{Communication}
%%----------------------------------------------------------------------------
%
%Before commencing with the design of each component, it is important to specify how the components in the system will communicate with each other as this can affect their construction. Considering that the sample application tries to resemble implementations that are widely used in the industry, the components to be created in this project will expose REST API endpoints and will communicate over HTTP protocol. This provides the right degree of customizability on the component level while allowing loose-coupling on the system level. 


%\begin{itemize}
%	\item master-worker architecture
%	\item REST API interfaces
%	\item use-case
%	\begin{itemize}
%		\item submitting computation jobs
%		\item distributing jobs among worker nodes
%		\item persisting job results
%		\item querying job results
%	\end{itemize}
%	
%\end{itemize}


%----------------------------------------------------------------------------
\subsection{Components}
%----------------------------------------------------------------------------

In the following sections, each component and their responsibilities are presented.

%----------------------------------------------------------------------------
\subsubsection{Backend} \label{design-backend}
%----------------------------------------------------------------------------

%\begin{itemize}
%	\item provides a REST API interface for submitting new jobs and querying their result
%	\item forward submitted jobs to worker nodes
%	\item stores the result of finished jobs in a database
%	\item exposes a metrics endpoint for external monitoring solutions
%	\item exposes health endpoint that can be consumed to verify that the system works in a functionally correct way
%\end{itemize}
%
%responsibilites + API + health endpoint

The backend is responsible for handling task inputs from clients and creating task definitions based on them that it will forward to worker components. Upon receiving a task result from a worker, the backend persists the result in a database and makes it possible for clients to query it.

In order to be able to monitor the behavior and state of the backend component, it should be able to expose different kinds of metrics about itself. From an operations point of view it is quite important that each component have a so called health endpoint that can be used to tell if the given component is up and running. Clients and monitoring tools can consume this endpoint to make sure if a service is available. However, sometimes it is not enough information if a service is up or down. Consider one of the multiple cases when the backend is running, but suddenly the database connection is lost due to some failure. Although the backend is up but it cannot function correctly. This leads to the conclusion that when the health endpoint of the backend is consumed, the result should indicate if there are problems in any of the dependencies of the backend which can disrupt its correct functionality. This way the users and the maintainers of the service can be sure that the system can function correctly if the health endpoint returns without failure.

Summary of the required interfaces: \begin{itemize}
	\item Task input submission
	\item Task result query
	\item Health endpoint
\end{itemize}

%----------------------------------------------------------------------------
\subsubsection{Worker}
%----------------------------------------------------------------------------

%\begin{itemize}
%	\item provides a REST API interface to accept jobs from the backend to execute
%	\item exposes a metrics endpoint for external monitoring solutions
%	\item exposes health endpoint
%\end{itemize}
%
%responsibilites + API + health endpoint

The role of a worker instance is to listen for new task submissions from the backend and execute these tasks upon receiving them. Completed tasks should be sent back to the backend where the results will be saved in a persistent way.

Observability is essential here as well. The system needs to be able determine which worker instances are running and if there are idle ones that can accept new task submissions. If there is not any free worker, new instances should be deployed. If there are multiple idle workers but no task to execute, then the system should scale in, stopping a couple of idle worker instances. To achieve that, the worker component should be able to expose information about itself if it is up and if it is currently busy working on a task or not.

Summary of the required interfaces: \begin{itemize}
	\item Listen for new tasks to execute
	\item Health endpoint
	\item Metrics endpoint
\end{itemize}


%----------------------------------------------------------------------------
\subsubsection{Message Queue} \label{design-message-queue}
%----------------------------------------------------------------------------

%\begin{itemize}
%	\item connects the backend with the worker nodes
%	\item as the number of worker nodes is dynamic, it would be not feasible for the backend to try to keep record of all the running workers
%	\item the backend sends the jobs to the workers via this message queue
%	\item the the workers also use this to send back the finished jobs (at the moment, we could skip the message queue on the way back, but this way we do not need much modification if there would be more than one backend in order to \eg be able to handle a bigger load)
%\end{itemize}

The goal of the message queue is to connect the backend and the worker instances. As the number of workers can dynamically change over time, it is not evident for the backend where to send new task assignments.

A possible solution could be that the backend somehow internally keeps track of the running worker instances but would lead to much overhead both on the application logic level and on the network communication layer.

Instead, a third component - a message queue - is introduced to the system. As its name suggests, it is a queue which behaves like a \emph{First In First Out} buffer. The backend can push new task assignments to the queue without the need to know which worker instance will process it. On the other end of the queue the worker instances wait for new tasks in the queue and when one appears, one of the worker takes it from the queue and starts working on it. Notice that this method is also applicable for the other direction. To prepare for situations where there can be multiple backend components, the message queue can be used to by the workers to send back completed tasks to the backend service without knowing how many backend instances are actually in the system.

This pattern enforces loose coupling in the system and neither the backend nor the workers do not have to know about each other, they just need to know the message queue to produce and to consume new tasks. 

%----------------------------------------------------------------------------
\subsubsection{Database}
%----------------------------------------------------------------------------

%\begin{itemize}
%	\item stores the jobs with their result 
%	\item serves queries made by the backend component
%\end{itemize}

The database is responsible for storing the tasks in the system in a durable way. It provides an interface through which it is possible to execute CRUD operations on the task entities.

%----------------------------------------------------------------------------
\section{Implementation}
%----------------------------------------------------------------------------

This section describes the implementation details and their justification for each component in the sample application.

%\begin{itemize}
%	\item Introduce the general problem it solves (naive implementation of Fibonacci - this is implementation)
%	\item Docker
%\end{itemize}

%----------------------------------------------------------------------------
\subsection{The Task}
%----------------------------------------------------------------------------

The motivation for having a use-case that drives the architectural design was emphasized in the previous section (\ref{design}). The specific task that the system can execute is calculating the value of a given element in the Fibonacci sequence. The clients can send the backend which Fibonacci number to calculate as input. For example if the client sends the number 6 as input, a worker will execute a task which result will be 8.

At first glance, it seems to be an overly simple application, but one has to keep in mind, that the specific task that the worker components can execute is in fact can be anything. This simple computation was chosen, because it is easy to parameterize, the magnitude of the input correlates well with execution time and the implementation of the logic does not divert the focus from the main goals of the project.

%----------------------------------------------------------------------------
\subsection{Containerization}
%----------------------------------------------------------------------------

The section that describes the requirements of the sample application (\ref{sample-app-requirements}) states that containerization is crucial in order to create a scalable microservice application. There are several containerization technologies used in the industry, but perhaps the most popular is Docker \cite{Docker} which can be viewed as the de facto containerization technology adopted by the industry. Because of this, all the components in the system are packaged with Docker.


%----------------------------------------------------------------------------
\subsection{Backend}
%----------------------------------------------------------------------------

%\begin{itemize}
%	\item Spring Boot Java
%	\item introduce Job model
%	\item introduce REST API
%	\item db connection
%	\item introduce health check
%	\item introduce Message Queue integration
%	\item spring bootBuildImage - reference later in CI/CD pipeline
%\end{itemize}

The backend component is written in the Java programming language using the Spring Boot framework that facilitates easy creation of stand-alone, production grade Spring based applications that can be run with minimal configuration \cite{SpringBoot}.

%----------------------------------------------------------------------------
\subsubsection{Job model}
%----------------------------------------------------------------------------

% TODO class diagram?

To be able to easily manage tasks, model class named Job is defined that represents a single Fibonacci number computation. It is a common POJO (Plain Old Java Object) that stores the input and the result of a task along with an unique identifier. A summary the fields of the class can be seen in Figure \ref{fig:job_model}.

\begin{figure}[h]
	\centering
	\includegraphics[width=40mm, keepaspectratio]{figures/job_class.png}
	\caption{Job class}
	\label{fig:job_model}
\end{figure}

%----------------------------------------------------------------------------
\subsubsection{Data persistence}
%----------------------------------------------------------------------------

When the backend component receives a task input from a client it creates a Job instance representing the task with an empty result and saves this object in the database. The reason of leaving the result field is evident as the task has not been executed by any of the workers and the backend does not know the result, but it is also quite practical to be able to tell at any point of the time which tasks have been completed and which have not. This feature will come handy when the test framework is used to measure the functional performance of the system.

The backend uses Spring Data JPA \cite{SpringDataJPA} to implement a data access layer without the need of having many lines of boilerplate code. To be able to store Job objects in the database, a couple of configurations should be made. The Job class needs to annotated with the \texttt{@Entity} annotation, indicating that this is a JPA entity so Spring Data JPA will know it must map this class in a table in the database. In order to be able to execute queries against the database in the program, a repository interface must be defined that Spring will use to generate the data accessing layer implementation with default CRUD operation. Lastly, the parameters of the database connection should be provided for the backend. This can be done in the \texttt{application.yaml}.

\begin{minipage}{\linewidth}
	\begin{lstlisting}[language=java, caption={\texttt{JobRepository} interface}, label={lst:JobRepository}]
		@Repository
		public interface JobRepository extends JpaRepository<Job, Long> {
			
			@Query("SELECT j FROM Job j WHERE j.result IS NULL")
			List<Job> findUnfinishedJobs();
			
			@Query("SELECT j FROM Job j WHERE j.result IS NOT NULL")
			List<Job> findFinishedJobs();
		}
	\end{lstlisting}
\end{minipage}

\begin{minipage}{\linewidth}
	\begin{lstlisting}[caption={Configuring the database connection}, label={lst:application-yaml-db}]
	# Database Properties
	database:
		host: ${MYSQL_DB_HOST:localhost}
		port: ${MYSQL_DB_PORT:3306}
		db: ${MYSQL_DB_DB_NAME:jobs}
	\end{lstlisting}
\end{minipage}

In \texttt{JobRepository} two additional methods are defined which will be later used to query \texttt{Job}s based on if they are completed or not.

%----------------------------------------------------------------------------
\subsubsection{Messaging}
%----------------------------------------------------------------------------

% TODO do we need more details?

As described in section \ref{design-message-queue} the backend uses a separate component acting as a message queue to forward new tasks to the worker components. This component (introduced later in section \ref{impl-message-queue}) implements the JMS API \cite{JMS} to handle messages between Java based applications.

This means that the backend should also use JMS to be able to send the tasks to the message queue. The implementation of this was inspired by the official Spring guide on handling messages with JMS \cite{JMSGuide}. The essential part is to configure a \texttt{JmsTemplate} that uses a connection to the message queue and using this object to send or receive messages. The actual implementation can be found under \texttt{messaging/activemq} package of the backend source code in the thesis repository \cite{ThesisRepo}.

%----------------------------------------------------------------------------
\subsubsection{Health check} \label{impl-backend-healthcheck}
%----------------------------------------------------------------------------

The importance of an mechanism that can determine if the backend is able to function correctly was mentioned in section \ref{design-backend}. As the system builds up from multiple components, checking if every part is working right consists of several steps. In the backend component, the health check includes four steps:

\begin{enumerate}
	\item \emph{Test database connection - }The backend test the connection to the database by attempting to save a test object. If it cannot be executed, the health check fails.
	\item \emph{Test worker availability - }The backend test the availability of the worker service by calling its health endpoint (described later in section \ref{impl-worker-interfaces}). If it returns with error, the the health check fails.
	\item \emph{Test message queue connection - }The backend sends a test message to the message queue which will be forwarded to one of the workers that will send back a reply. If the response is not received after a short amount of time, the health check fails.
	\item \emph{Test entire workflow with sample input - }Every 90 seconds the backend creates a dummy \texttt{Job} instance and sends it to the message queue and waits for response. Other non-test task execution reset the timer on this check. If there are not any successful task executions (dummy or real) in the last 90 seconds, the health check fails.
\end{enumerate}

%----------------------------------------------------------------------------
\subsubsection{Interfaces}
%----------------------------------------------------------------------------

The backend implements the interfaces described in section \ref{design-backend}.

\paragraph{Task input endpoint} This endpoint handles new task submission. Upon calling this endpoint the backend creates a \texttt{Job} instance with an empty result, saves it to the database and forwards it to the message queue.
\begin{itemize}
	\item \emph{Path - } \texttt{/api/v1/jobs}
	\item \emph{HTTP method - } \texttt{POST}
	\item \emph{Body - } a JSON object that has a single field named \texttt{input} with an integer value.
	\item \emph{Response - } a JSON object representing the created task (with empty result)
\end{itemize}

\paragraph{Task query endpoint} This endpoint can be used to retrieve all the tasks. Upon calling this endpoint the backend queries the database to get all the tasks stored there.
\begin{itemize}
	\item \emph{Path - } \texttt{/api/v1/jobs}
	\item \emph{HTTP method - } \texttt{GET}
	\item \emph{Body - } None
	\item \emph{Response - } a JSON array containing all the tasks stored in the database
\end{itemize}

\paragraph{Health endpoint} Upon calling this endpoint, the backend executes the health checks described in section \ref{impl-backend-healthcheck}.
\begin{itemize}
	\item \emph{Path - } \texttt{/api/v1/health}
	\item \emph{HTTP method - } \texttt{GET}
	\item \emph{Body - } None
	\item \emph{Response - } If any of the steps fail, the endpoint returns with a HTTP 500 response, otherwise with a HTTP 200 response.
\end{itemize}

%----------------------------------------------------------------------------
\subsection{Worker}
%----------------------------------------------------------------------------

Similarly as the backend, the worker component is written in Java as well using the Spring Boot framework.

%\begin{itemize}
%	\item Spring Boot Java
%	\item introduce REST API
%	\item db connection
%	\item introduce Message Queue integration
%	\item introduce health check
%	\item jobmodel (same)
%	\item spring bootBuildImage - reference later in CI/CD pipeline
%\end{itemize}

%----------------------------------------------------------------------------
\subsubsection{Interfaces} \label{impl-worker-interfaces}
%----------------------------------------------------------------------------


%----------------------------------------------------------------------------
\subsection{Message Queue} \label{impl-message-queue}
%----------------------------------------------------------------------------

\begin{itemize}
	\item configuration? image?
\end{itemize}

%----------------------------------------------------------------------------
\subsection{Database}
%----------------------------------------------------------------------------

\begin{itemize}
	\item configuration? image?
\end{itemize}


\subsection{Kubernetes deployment}


\begin{itemize}
	\item helm chart
	\item K8s pod, depl, svc exapmle (one for each)
	\item HPA definition, metrics server
\end{itemize}
















